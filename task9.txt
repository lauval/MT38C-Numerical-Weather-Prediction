# Author: Laurent Valentin

# We begin by importing the necessary libraries:
import numpy as np
import matplotlib.pyplot as plt
import scienceplots 
from numpy.fft import rfft, rfftfreq, irfft 

# Then we define constants
phi_0     = 1e5
f_0       = 1e-4
x_0_psi   = 1.25e7
y_0_psi   = 2.5e6
A         = 3e-2
sigma_psi = 7.5e5

# Set up a grid
grid_space = 2.5e4 # common grid spacing

# adding 1e5 to both limits so that np.arrange() includes the upper limit
upper_x_limit = 2.5e7 + grid_space
upper_y_limit = 5e6 + grid_space

x = np.arange(0, upper_x_limit, grid_space)
y = np.arange(0, upper_y_limit, grid_space)

# define 2D X and Y arrays:
Y, X = np.meshgrid(y, x)

# Now that we have our 2D grid, we define the streamfunction as follows:
psi  = phi_0/f_0 * (1 - (A * np.exp(-((X-(x_0_psi))**2 + (Y-y_0_psi)**2)/(2 * (sigma_psi**2)))))

# Then we define a function for generating the periodic vorticity field based on our streamfunction and grid:
def generate_vorticity(streamfunction, y, x):
    """
    Generate vorticity field from streamfunction using the centered difference scheme.

    Parameters:
    - streamfunction (numpy.ndarray): 2D array representing the streamfunction.
    - y (numpy.ndarray): 1D array representing the y-axis values.
    - x (numpy.ndarray): 1D array representing the x-axis values.

    Returns:
    - xi (numpy.ndarray): 2D array representing the vorticity field.
    """
    N = np.shape(y)[1]  # length in the y direction
    M = np.shape(x)[0]
    dx = dy = y[0, 1] - y[0, 0]  # extract grid space step from y array
    
    # Implement the 3 point centred difference scheme for the interior points of the vorticity
    d_y_2 = (streamfunction[:, 2:N] - 2 * streamfunction[:, 1:(N-1)] + streamfunction[:, 0:(N-2)]) / (dy**2)

    d_x_2 = (streamfunction[2:M, 1:(N-1)] - 2 * streamfunction[1:(M-1), 1:(N-1)] + streamfunction[0:(M-2), 1:(N-1)]) / (dx**2)

    # Implement the boundary conditions for the second derivative with respect to x
    d_x_2_first = (streamfunction[1, 1:(N-1)] - 2*streamfunction[0, 1:(N-1)] + streamfunction[-1, 1:(N-1)]) / (2 * dx)
    d_x_2_last  = (streamfunction[0, 1:(N-1)] - 2*streamfunction[-1, 1:(N-1)] + streamfunction[-2, 1:(N-1)]) / (2 * dx)

    # Stack the boundary conditions onto the second derivative arrays
    d_x_2 = np.vstack((d_x_2_first, d_x_2))
    d_x_2 = np.vstack((d_x_2, d_x_2_last))

    # Combine the second derivatives to calculate the vorticity
    xi = d_x_2 + d_y_2
    
    return xi

# Generate the vorticity field using our function
xi = generate_vorticity(psi, Y, X)

# Now we can calculate the fourier coefficients of the vorticity field.
# first, we define a variable to store the fourier transform (fourier coefficients) of xi
xi_hat = rfft(xi, axis=0)

# Then we generate the set of fourier coefficients for the streamfunction. 
# These will be used as the boundary conditions when solving the tri-diagonal system of equations.

# Generate the fourier coefficients for the streamfunction
psi_hat = rfft(psi, axis=0)

northern_boundary = psi_hat[:, 0]
southern_boundary = psi_hat[:, -1]

# Now we can set up our RHS solution vector:

# first we add an axis to both the northern and southern boundary arrays
northern_boundary = northern_boundary[:, np.newaxis]
southern_boundary = southern_boundary[:, np.newaxis]

# then we concatenate the arrays together along the column axis
xi_hat = np.concatenate((northern_boundary, xi_hat, southern_boundary), axis=1)

# then we calculate the wavenumber corresponding to each m value:
k = rfftfreq(np.shape(x)[0], grid_space/(2.0*np.pi))

# And we define the function that creates the tri-diagonal matrix as specified in the task brief:
def generate_tridiagonal_matrix(N, k, grid_spacing=2.5e4):
    """
    Generate a tridiagonal matrix for solving the tri-diagonal system of equations.

    Parameters:
    - N (int): Number of points in each dimension of the matrix.
    - k (numpy.ndarray): 1D array representing the wavenumbers.
    - grid_spacing (float): Size of the grid spacing in the y-direction.

    Returns:
    - matrix (numpy.ndarray): Tridiagonal matrix of size N x N.
    """
    # define variables and constants
    dy = grid_spacing
    lambda_ = -(k**2)

    # initiate matrix
    matrix = np.zeros((N,N))
    F = 1/(dy**2)

    # fill the matrix with the correct values by looping through the rows first, then the columns:
    for i in range(N): 
        for j in range(N): 

            # fill the corners of the matrix with 1:
            if (i == j == 0) or (i == j == N-1): 
                matrix[i,j] = 1 
                
            # fill the rest of the matrix with the correct values    
            else:

                # if the row and column are the same, fill the diagonal with -2F
                if i == j: 
                    matrix[i,j] = lambda_ - 2*F

                # if the row and column are next to each other, fill the matrix with F
                elif (i == j+1 or i == j-1) and (i != 0 and i != N-1):
                    matrix[i,j] = F

    return matrix

# And now we loop over each column, solving the tri-diagonal system of equations for every value of y:

# Create an empty 2D array to store psi_hat values
psi_hat_array = np.empty((np.shape(psi_hat)[0], 0))

# save number of columns to a variable for use in the loop
num_columns = np.shape(Y)[1]

# Loop through the number of columns where each column is represented by the letter 'i':
for i in range(num_columns):
    N = np.shape(k)[0]
    matrix = generate_tridiagonal_matrix(N, k[i])

    # Solve the system of equations
    psi_hat = np.linalg.solve(matrix, xi_hat[:, i])

    # Append psi_hat values to the psi_hat_array along axis=1
    psi_hat_array = np.append(psi_hat_array, psi_hat[:, np.newaxis], axis=1)

# Invert the final psi_hat_array to get the streamfunction
psi_new = irfft(psi_hat_array, axis=0)

# Compare the two solutions for the streamfunction:
fig, ax = plt.subplots(1, 2, figsize=(5, 5))
ax[0].contourf(psi_new)
ax[1].contourf(psi)
plt.show()